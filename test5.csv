ID,Explanation,Context,Code,Correct Code
16,"Use only the VTT mode for editing vectors when rdi.smartVec().label().copyLabel() is
used for the label",mode for editing vectors at runtime,"rdi.smartVec().vecEditMode(TA::VECD);

RDI_BEGIN();
rdi.smartVec()
    .label(""sLabel"").copyLabel(false).pin(A)
    .writeData(""rt"", 8, 0)
    .execute();

rdi.smartVec()
    .label(""sLabel"").copyLabel(false).pin(A)
    .writeData(""rt"", 8, 8)
    .execute(); // 
RDI_END();","rdi.smartVec().vecEditMode(TA::VTT);

RDI_BEGIN();
rdi.smartVec()
    .label(""sLabel"").copyLabel(false).pin(A)
    .writeData(""rt"", 8, 0)
    .execute();

rdi.smartVec()
    .label(""sLabel"").copyLabel(false).pin(A)
    .writeData(""rt"", 8, 8)
    .execute(); // 
RDI_END();"
32,BUG : Port name & pin config mismatch instead of execute it will burst twice,"rdi.port(TA::MULTI_PORT).func()
This function allows multi-port labels to be combined to form a new burst. It is used for
dynamic mode in the func() class only.Multi-port burst with .port(TA::MULTI_PORT)","RDI_BEGIN();
rdi.port(""pt1"").dc().pin(""dig2"").vForce(1 uA).burst();
rdi.port(TA::MULTI_PORT).func().burst(""MPBurst2"").burst(); // n
rdi.port(""pt2"").digCap().pin(""dig1"").samples(8).execute();
rdi.port(TA::MULTI_PORT).func().burst(""MPBurst1"").burst();
RDI_END();","RDI_BEGIN();
rdi.port(""pt1"").dc().pin(""dig"").vForce(1 V).execute();
rdi.port(TA::MULTI_PORT).func().burst(""MPBurst1"").execute(); // n
rdi.port(""pt2"").digCap().pin(""dig2"").samples(8).execute();
RDI_END();"
25,"BUG : Replacing the lifecycle order 
and calling RDI_END before RDI_BEGIN inverts 
the intended session/transaction scope and 
will typically cause runtime failures or no-ops.","rdi.protocol().write()
Writes a piece of data on a specified address at runtime","ARRAY_I write_data(2); // Define a variable for a dual-site test
write_data[0]=0x1;
write_data[1]=0x2;
rdi.runTimeVal(""data"",write_data); // Site data array
RDI_END();
rdi.protocol().pname(""i2c"").write(0x4,""data"").execute();
RDI_BEGIN();","ARRAY_I write_data(2);
write_data[0]=0x1;
write_data[1]=0x2;
rdi.runTimeVal(""data"",write_data); // Site data array
RDI_BEGIN();
rdi.protocol().pname(""i2c"").write(0x4,""data"").execute();
RDI_END();"
10,changed the function names,"Reads the actual measured humidity of the selected PMUX card from the hardware and
stores it into a software cache.","RDI_BEGIN();
rdi.pmux(4).module(""02"").readHumanSeniority().execute();
RDI_END();
int hum = rdi.id(4).getHumanSeniority(""02"");","RDI_BEGIN();
rdi.pmux(4).module(""02"").readHumSensor().execute();
RDI_END();
int hum = rdi.id(4).getHumSensor (""02"");"
26,"Measurement binding/order bug on Pin2.
Specifics: iMeas() is applied immediately after the first group (waveform + repeat), before the additional groups are appended then instead of execute it will read().","rdi.dc().addWaveform()
Adds one or more waveforms in an execute() operation.
This function supports digital cards and DC Scale cards (PMU and DPS operating
modes).","anaWaveform wav1(""wav1""), wav2(""wav2""), wav3(""wav3"");
RDI_BEGIN();
rdi.dc().pin(""Pin1"").vForce().waveform(wav1)
  .addWaveform(wav2)
  .addWaveform(wav3, 2)      // Add ""wav3"" twice
  .FS(250 /* kHz */).execute();
rdi.dc().pin(""Pin2"").vForce().waveform(wav1).repeat(2)
  .iMeas()                   
  .addWaveform(wav2, 3)      // Add ""wav2"" three times (group 2..4)
  .FS(250 /* kHz */).read();
RDI_END();","anaWaveform wav1(""wav1""), wav2(""wav2""), wav3(""wav3"");
RDI_BEGIN();
 rdi.dc().pin(""Pin1"").vForce().waveform(wav1)
 .addWaveform(wav2).addWaveform(wav3,2) // Add ""wav2"" once and
 .FS(250 kHz).execute();
 rdi.dc().pin(""Pin2"").vForce().waveform (wav1).repeat(2)
 .addWaveform(wav2,3).iMeas() // Add ""wav2"" three times and me
 .FS(250 kHz).execute();
RDI_END();"
